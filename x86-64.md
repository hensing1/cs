# x86-64-Assembly

## Allgemeines

Prozessoren mit der x86-64-Architektur realisieren den (64-Bit-)*x86-Instruktionssatz*.
Davon zu unterscheiden ist die 32-Bit-x86-Architektur, welche mit i386 bezeichnet wird.

- Speicher wird byteweise adressiert
- Instruktionen können auf einem oder mehreren Bytes im Arbeitsspeicher arbeiten
- Bytereihenfolge: [[Glossar#Little-Endian, Big-Endian| Little Endian]]
- [Liste einiger Befehle und was sie tun](http://www.jegerlehner.ch/intel/IntelCodeTable.pdf)
- Kann mit [nasm](https://nasm.us/doc/nasmdoc0.html) kompiliert werden

## Prozessorregister

| Funktion                    | 64 Bit   | 32 Bit   | 16 Bit  | 8 Bit      |
| --------------------------- | -------- | -------- | ------- | ---------- |
| Akkumulator                 | `rax`    | `eax`    | `ax`    | `ah`, `al` |
| Allg. Register              | `rbx`    | `ebx`    | `bx`    | `bh`, `bl` |
| Schleifencounter            | `rcx`    | `ecx`    | `cx`    | `ch`, `cl` |
| Datenregister               | `rdx`    | `edx`    | `dx`    | `dh`, `dl` |
| Source f. Stringoperationen | `rsi`    | `esi`    | `si`    |            |
| Dest. f. Stringoperationen  | `rdi`    | `edi`    | `di`    |            |
| Base pointer                | `rbp`    | `ebp`    | `bp`    |            |
| Stack pointer               | `rsp`    | `esp`    | `sp`    |            |
| Allg. Register              | `r8`     | `r8d`    | `r8w`   | `r8b`      |
|                             | ...      | ...      | ...     | ...        |
|                             | `r15`    | `r15d`   | `r15w`  | `r15b`     |
| Prozessor-Statusflags       | `rflags` | `eflags` | `flags` |            |

`rax` ist ein Register, und `eax` ist die unteren 32 Bit desselben Registers, usw.
`ah` ist die oberen 8 Bit von `ax`, `al` die unteren, usw.

Es gibt eine Erweiterung für x86-64 namens APX, welche noch die Register `r16` bis `r31` hinzufügt.

## Prozessorflags
![[x86-Flags.png|400]]

Wichtige Statusflags: 
 - C: Carry - unsigned Operation zu groß oder $<0$
 - O: Overflow - signed Operation zu groß oder zu klein
 - S: Sign - Vorzeichen des Ergebnis
 - Z: Zero - Ergebnis ist 0
 - P: Parity - Ergebnis hat gerade Anzahl an Einsen

Welche Operationen welche Flags setzen, steht in der Code Table.

## Kompilieren
1. Erstellen von Object-Datei:
	- `nasm -f elf64 -o [Outputdatei] [Inputdatei]`
2. Linken:
	- `ld -o [Outputdatei] [Input-(Objekt-)datei]`, oder
	- `clang -o [Outputdatei] [Input-(Objekt-)datei]`
3. Debuggen:
	- `gdbtui ./[Outputdatei]`

## Aufbau der Quelldatei

### Makros
Mit 
```asm
%macro [name] [num_params]
	...
%endmacro
```
können Makros definiert werden. 
Innerhalb des Makros kann mit `%1`, `%2`, ... auf die übergebenen Parameter zugegriffen werden.
### .data-Section
Mit `SECTION .data` beginnt der Datenteil des Assembler-Programms. 

Hier werden Label für String-Konstanten, globale Variablen, etc. angelegt, z.B. 
```asm
hello: db "Hello World\n"
```

Hier wird mit `db` (Define Byte) eine Reihe von Bytes für den String "Hello World\n" reserviert und initialisiert. 
Die Adresse dieses Strings (das erste Byte) ist dann mit dem Label `hello` abrufbar.

#### Direktiven für die .data-Section
1. `db` (Define Byte): This directive is used to define one or more bytes of data. It allows you to define character data, numeric values, or any other byte-sized data.
2. `dw` (Define Word): This directive is used to define one or more words of data. A word typically represents a 16-bit value.
3. `dd` (Define Doubleword): This directive is used to define one or more doublewords of data. A doubleword typically represents a 32-bit value.
4. `dq` (Define Quadword): This directive is used to define one or more quadwords of data. A quadword typically represents a 64-bit value.
5. `dt` (Define Ten Bytes): This directive is used to define ten bytes of data. It's often used for defining floating-point values.
6. `resb`, `resw`, `resd`, `resq`, `rest` (Reserve Space): These directives are used to reserve a specified number of bytes, words, doublewords, quadwords, or ten bytes, respectively, without initializing them.
7. `equ` (Equate): This directive is used to define a constant value or expression. It doesn't allocate memory, but it assigns a name to a specific value or expression.
8. `align` (Data Alignment): This directive is used to align data on a specified byte boundary, ensuring that the data is located at a memory address that is a multiple of the specified value.
9. `times` (Repeat Data): This directive is used to repeat a specified data item a certain number of times.
10. `ascii` and `asciz` (Define ASCII Strings): These directives are used to define ASCII character strings, with `asciz` terminating the string with a null (zero) byte

### Globale Linker-Label
Man muss angeben, bei welches Label für den Linker sichtbar sein soll. Das macht man mit
```asm
global [label]
```

> Üblicherweise wird in NASM das Symbol `_start` für den Einstiegspunkt in ein Programm verwendet. Der Linker (`ld`) erlaubt aber die Spezifizierung beliebiger Labels mit dem Parameter `-e`.

### .text-Section
Hier steht der eigentliche Quellcode.

## Syscalls

Man kann System-Calls machen, indem man in `rax` einen Syscall-Identifikator reinschreibt (z.B. `60` für `SYS_exit`) und dann `syscall` ausführt. In die anderen Register gehören evtl. noch Parameter für den Syscall. 

### Linux-Syscalls

| Name      | `rax` | `rdi`                | `rsi`                              | `rdx`             |
| --------- | ----- | -------------------- | ---------------------------------- | ----------------- |
| SYS_read  | 0     | 0 für STDIN          | Pointer zu Buffer, wo es reinkommt | Länge des Buffers |
| SYS_write | 1     | 0 für STDOUT         | Pointer zu Buffer mit Daten        | Länge des Bufers  |
| SYS_open  | 2     | Pointer zu Dateiname | Read/Write flags                   |                   |
| SYS_close | 3     | Pointer zu Dateiname |                                    |                   |
| SYS_exit  | 60    | return code          |                                    |                   |

## Assembler-Syntax: Intel vs. AT&T

GNU-Assembler: AT&T
NASM: Intel  <- Sysprog

| Intel                              | AT&T                                |                                             |
| ---------------------------------- | ----------------------------------- | ------------------------------------------- |
| `mov rax, 1`                       | `movq $1, %rax`                     | Intel: dest <- source, AT&T: source -> dest |
| `mov rax, [rbx]`                   | `movq (%rbx), %rax`                 | Indirekte Adressierung                      |
| `cmd foo, [base+index*scale+disp]` | `cmd disp(basi, index, scale), foo` | Segmentregister                             |

Bei Intel kann man bei `mov` alle möglichen Register angeben, unabhängig von ihrer Größe.
Bei AT&T muss man mit `movb`, `movw`, `movl` oder `movq` angeben, ob man ein Byte, Word (16 Bit), Long (32 Bit) oder Quad (64 Bit) verschiebt.
Verschiebt man Sachen per indirekter Adressierung in Intel, gibt man mit `byte ptr`, `word ptr`, `dword ptr` oder `qword ptr` die Größe an (bei NASM wird `ptr` weggelassen).

## Adressierungsarten

- Registeradressierung
	- `mov rbx, rdi`
- Unmittelbare Adressierung
	- `mov rbx, 1000`
- Direkte Adressierung
	- `mov rbx, [1000]`
- Register-indirekte Adressierung
	- `mov rbx, [rax]`
- Basisregister-Adressierung
	- `mov rax, [rsi+10]`

Allgemeine Indizierung: `mov register, segreg:[base+index*scale+displ]`
`segreg` ist hierbei ein spezielles Register, das auf Segmente (z.B. die [[x86-64#.data-Section|.data-Section]]) zeigt. Im 64-Bit protected mode wird es kaum genutzt.

Segmentregister werden iW. nur vom Betriebssystem benutzt ("real mode"), für gewöhnliche Programme muss (und darf) man nicht darauf zugreifen ("protected mode").

## Calling Conventions

### Funktionsaufruf

Keywords:
- `call <label>`
	- pusht Rücksprungadresse (Adresse unterhalb des Befehls) auf den Stack
	- springt zu `label`
- `ret`
	- holt sich Rücksprungadresse vom Stack (inkl. pop)
	- springt dorthin

**Funktionsprolog: Stackframe aufbauen**
Zu Funktionsbeginn zeigt der Base Pointer `rbp` noch auf den Beginn des alten Stackframes.
Er wird also auf dem Stack gesichert: 

	push rbp

Der neue Stack Frame kommt oben auf den Stack. Also:

	mov rbp, rsp

An `[rbp]` steht nun die Adresse vom alten Stack frame, darunter (also `[rbp + 8]`) ist die Rücksprungadresse.

Äquivalent (aber langsamer) ist `enter 0,0`.

**Lokale Variablen**
Lokale Funktionsvariablen werden auf dem Stack abgelegt.

**Funktionsepilog: Stackframe abbauen**

	mov rsp, rbp
	pop rbp
	ret
Äquivalent ist `leave`, gefolgt von `ret`.

#### Stack Alignment

Auf i386 (d.h. 32-Bit x86) ist der Stack immer 4-Byte-Aligned, d.h. Speicheradressen auf dem Stack sind immer durch 4 teilbar.
Unmittelbar vor Funktionsaufrufen wird der Stack (auf neueren Systemen) auf 16 Byte aligned.

Auf x86-64 wird der Stack immer vor einem Funktionsaufruf auf 16 Byte aligned.

Der Grund ist, dass Zugriff auf durch 4 bzw. 16 teilbare Adressen schneller geht. Nicht alignte Adressen brauche ggf. extra Prozessorzyklen.

### System V AMD64 ABI

Integer- und Pointerparameter kommen der Reihe nach in folgende Register:
1. `rdi`
2. `rsi`
3. `rdx`
4. `rcx`
5. `r8`
6. `r9`

Gibt es weitere Parameter, kommen diese auf den Stack.

Die Werte von `rbx`, `rbp`, `rsp` und `r12` bis `r15` müssen von der aufgerufenen Funktion wiederhergestellt werden.

## Call Stack

```assembly
section .text

my_function:
    ; Function prologue
    push rbp            ; Save the old base pointer
    mov rbp, rsp        ; Set up the new base pointer
    sub rsp, 4          ; Allocate space for a local variable

    ; Accessing local variable using base pointer
    mov DWORD [rbp-4], 42

    ; Function epilogue
    mov rsp, rbp        ; Restore the stack pointer
    pop rbp             ; Restore the base pointer

	return
```
