Datum: 14.11.
[[Master/Semester 1/IT Security/Slides/06 Malware Analysis.pdf|Folien]]
[[Master/Semester 1/IT Security/Übungen/06 Malware Analysis.pdf|Übung]]
# Malware Analysis

## PDFs

PDF-Dateien sind eine große Ansammlung von *Objekten*.

Es gibt:
- Direct object
	- Name object: `/Name`, `/anything`
	- String: `(literal)`, `<789abcdef>` hex encoded
	- Integer
	- Array (nicht typisiert): `[(hello) /world null true false]`
	- Dictionary: `<</Key1 /AnyObject /Key2 8 0 R /Key3 null>>`
- Indirect objects
	- Starten mit `<ID> <Gen-No> obj`
	- enden mit `endobj`
	- können referenziert werden mit `<ID> <Gen-No> R`

Es gibt ein **Start-Dict**. Die Position dieses Start-Dicts steht als *Byte-Offset* ganz unten in der PDF:
```pdf
startxref
28122
%%EOF
```

### Actions

Ein *Action Dictionary* sieht z.B. so aus:
```pdf
6 0 obj
<<
	/Type /Action
	/S /Launch
	/F (/tmp/malware.py)
>>
endobj
```

Mögliche Werte für `\S`:
- `/Launch`: starte Programm
- `/JavaScript`: Führe JavaScript aus
- `/SubmitForm`: Schicke Daten an bestimmte URL
- `/URI`: öffne URI

Weiterhin gibt es *Catalog Dictionaries*, die eine `/OpenAction` haben können. Diese OpenAction ist ein Action Dictionary. 
Die OpenAction wird *ausgeführt, wenn das Dokument geöffnet wird*.

Action Dictionaries können auch als Annotation für eine Seite angegeben werden, und werden ausgeführt, wenn man drauf klickt.

### Obfuscation
Es gibt verschiedene Varianten, Dinge in PDFs zu verschleiern:
- Strings in Hex-Darstellung
- Objekte können als `stream` komprimiert werden
- Objecte können verschlüsselt werden

Tools für Analyse: `qpdf` für Deobfuscation, `peepdf` für Überblick, ansonsten normaler Texteditor

## PE Analyse

PE ist das Dateiformat für ausführbare Dateien und Bibliotheken, das auf Windows verwendet wird.

Die meiste Malware ist für Windows, deshalb schauen wir uns PE an.

Andere Calling Conventions: *stdcall* und *Microsoft x64* statt cdecl und System V

Andere Tools:
- `x64dbg` statt `gdb`
- Statische Analyse: ghidra, ida, binja

### Obfuscation

Es gibt verschiedene Arten der Verschleierung:

- String obfuscation
- Control flow objuscation
	- z.B. jmp statt call
- packing
	- Teil des Codes verschlüsseln und bei Runtime entschlüsseln
- bloating
	- unnötigen Code in den code packen


**Möglichkeiten für String Obfuscation**
- *Verschlüsselung*: verschlüssele z.B. die einzelnen Buchstaben
	- z.B. xor mit einem Schlüssel
	- baue Code für Entschlüsselung mit in die Executable
- *Stack Strings:* Anstelle von String literal, teile String auf Variablen auf, die nacheinander auf dem Stack liegen
	- -> immernoch zusammenhängender Speicher wie bei String/Char array
	- -> mehrere Chars können zusammengefasst werden, Datentyp ist beliebig
	- da der Stack in Richtung kleinerer Adressen wächst, müssen die Werte in der Funktion rückwärts definiert werden (Nullbyte zuerst)

Analysetools wie Ghidra haben die Funktion *retyping*, sodass Elemente von Stack Strings statisch als Chars eingesehen werden können.

Ansonsten: Programm im Debugger ausführen, und schauen, wann die Strings entschlüsselt werden.
Zum Beispiel:
- Wir haben eine Funktion, von der wir wissen, dass sie mit unverschlüsselten Strings aufgerufen werden muss
- Wir finden die Adresse dieser Funktion in x64dbg
- Das ist (anscheinend) nicht die Position des Function calls in der Binary
- Die letzten 2 Bytes sind meistens aber statisch, diese können wir in Ghidra wiederfinden
- Falls wir den richtigen Breakpoint gesetzt haben, können wir in den Registern nach den unverschlüsselten Werten schauen

### Anti-Debugging

Es gibt so Funktionen wie `IsDebuggerPresent()` aus der Windows-eigenen `debugapi.h`.
Ist eigentlich dazu da, dass das Programm zusätzliche Informationen ausspucken kann - wird aber auch von Malware benutzt, um abzuschalten, sobald ein Debugger anwesend ist.

#### Anti-Anti-Debugging

- *Patching:*
	- Wir können mit Analysetools alle Stellen, an denen auf Debugger geprüft wird, mit NOPs ersetzen
- *Returnwerte ändern:*
	- Wenn der Returnwert von `IsDebuggerPresent()` ausgewerted wird, können wir ihn auf `false` setzen
- *Tools:*
	- "ScyllaHide" macht sowas für einen

### Anti-Sandboxing

Malware kann überprüfen, ob sie sich in einem Sandbox-Environment befindet:

- Überprüfen, ob Dateien vorhanden sind, die nur in einer VM sind:
	- `System32\drivers\VBoxMouse.sys`
	- ...
- Malware-Analysten haben ihre Malware gerne in Ordnern mit Namen "Malware", "sample", usw. -> Malware kann ihren binary-path angucken
- Viele Informationen/Funktionen sind in VMs oft *nicht* vorhanden:
	- Exotische CPU-Instruktionen oft nicht implementiert
	- Funktionen, die CPU-Information zurückgeben, oft spezifisch für Sandbox
	- Gerätenamen
	- Daten für CPU-Temparatur

Tools gegen Anti-Sandboxing:
- https://github.com/nsmfoo/antivmdetection
- https://github.com/hfiref0x/VBoxHardenedLoader

Tools, die überprüfen, ob sie in einer VM laufen:
- https://github.com/LordNoteworthy/al-khaser
- https://github.com/a0rtega/pafish